#!/usr/bin/env python

# Copyright (C) 2022 CVAT.ai Corporation
#
# SPDX-License-Identifier: MIT

import argparse
import os
import os.path as osp
import re
import shutil
import sys
import textwrap
from glob import iglob
from typing import List

from inflection import underscore


class Processor:
    _reference_files: List[str]

    def __init__(self, *, input_dir: str, site_root: str) -> None:
        self._input_dir = input_dir
        self._site_root = site_root

        self._content_dir = osp.join(self._site_root, "content")
        self._sdk_reference_dir = osp.join(
            self._content_dir, "en/docs/api_sdk/sdk/reference"
        )
        self._templates_dir = osp.join(self._site_root, "templates")

    @staticmethod
    def _copy_files(src_dir: str, glob_pattern: str, dst_dir: str) -> List[str]:
        copied_files = []

        for src_path in iglob(osp.join(src_dir, glob_pattern), recursive=True):
            src_filename = osp.relpath(src_path, src_dir)
            dst_path = osp.join(dst_dir, src_filename)
            # assume dst dir exists
            shutil.copy(src_path, dst_path, follow_symlinks=True)

            copied_files.append(dst_path)

        return copied_files

    def _copy_pages(self):
        self._reference_files = self._copy_files(
            self._input_dir, "*/**/*.md", self._sdk_reference_dir
        )

    def _add_page_headers(self):
        HEADER_SEPARATOR = "---"

        for p in self._reference_files:
            with open(p) as f:
                contents = f.read()

            assert not contents.startswith(HEADER_SEPARATOR), p

            lines = contents.splitlines()

            assert lines[0].startswith("#")
            classname = lines[0][1:].strip()

            header = textwrap.dedent(
                """\
                %(header_separator)s
                title: '%(classname)s reference'
                linkTitle: '%(classname)s'
                weight: 10
                description: ''
                %(header_separator)s
            """
                % {"header_separator": HEADER_SEPARATOR, "classname": classname}
            )

            contents = header + "\n".join(lines[1:])

            with open(p, "w") as f:
                f.write(contents)

    def _extract_apis_summary(self, readme_path: str) -> str:
        with open(readme_path) as f:
            readme_contents = f.read()

        apis_summary = re.findall(
            r"## Available API Endpoints(.*)## Available Models",
            readme_contents,
            flags=re.DOTALL,
        )
        apis_summary = apis_summary[0].strip()
        assert len(apis_summary) > 0

        return apis_summary

    def _move_api_summary(self):
        SUMMARY_REPLACE_TOKEN = "{{REPLACEME:apis_summary}}"  # nosec

        apis_summary = self._extract_apis_summary(
            osp.join(self._input_dir, "README.md")
        )

        apis_index_filename = osp.join(
            osp.relpath(self._sdk_reference_dir, self._content_dir), "apis/_index.md"
        )
        apis_index_path = osp.join(
            self._templates_dir, apis_index_filename + ".template"
        )
        with open(apis_index_path) as f:
            contents = f.read()

        contents = contents.replace(SUMMARY_REPLACE_TOKEN, apis_summary)

        with open(osp.join(self._content_dir, apis_index_filename), "w") as f:
            f.write(contents)

    def _fix_page_links_and_references(self):
        """
        Replaces reference page links from full lowercase (which is generated by hugo from the
        orignal camelcase and creates broken links) ('authapi') to the minus-case ('auth-api'),
        which is more readable and works.
        Adds an extra parent directory part to links ('../') as hugo requires, even for neighbor
        files.
        """

        mapping = {}

        for src_path in self._reference_files:
            src_filename = osp.relpath(src_path, self._sdk_reference_dir)
            dst_filename = underscore(src_filename).replace("_", "-")
            dst_path = osp.join(self._sdk_reference_dir, dst_filename)
            os.rename(src_path, dst_path)
            mapping[src_filename] = dst_filename

        self._reference_files = [
            osp.join(self._sdk_reference_dir, p) for p in mapping.values()
        ]

        for p in iglob(self._sdk_reference_dir + "/**/*.md", recursive=True):
            with open(p) as f:
                contents = f.read()

            for src_filename, dst_filename in mapping.items():
                src_dir, src_filename = osp.split(osp.splitext(src_filename)[0])
                dst_filename = osp.basename(osp.splitext(dst_filename)[0])
                contents = re.sub(
                    rf"(\[.*?\]\()((?:\.\./)?(?:{src_dir}/)?){src_filename}((?:#[^\)]*?)?\))",
                    rf"\1../\2{dst_filename}\3",
                    contents,
                )

            with open(p, "w") as f:
                f.write(contents)

    def _fix_parsing_problems(self):
        """
        Adds angle brackets to freestanding links, as the linter requires. Such links can appear
        from the generated model and api descriptions.
        Adds escapes to freestanding square brackets to make persing correct.
        """

        # Borrowed from https://stackoverflow.com/a/31952097
        URL_REGEX = (
            # Scheme (HTTP, HTTPS):
            r"(?:(https?):\/\/)?"
            # www:
            r"(?:www\.)?"
            r"("
            # Host and domain (including ccSLD):
            r"(?:(?:[A-Z0-9][A-Z0-9-]{0,61}[A-Z0-9]\.)+)"
            # TLD:
            r"([A-Z]{2,6})"
            # IP Address:
            r"|(?:\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})"
            r")"
            # Port:
            r"(?::(\d{1,5}))?"
            # Query path:
            r"(?:(\/\S+)*)"
        )

        for p in self._reference_files:
            with open(p) as f:
                contents = f.read()

            contents = re.sub(
                r"(?:\A|[\.\s])(" + URL_REGEX + r")(?:[\.\s]|\Z)",
                r"<\1>",
                contents,
                flags=re.MULTILINE,
            )

            contents = re.sub(r"\[([^\[\]]*?)\]([^\(])", r"\[\1\]\2", contents)

            with open(p, "w") as f:
                f.write(contents)

    def run(self):
        assert osp.isdir(self._input_dir), self._input_dir
        assert osp.isdir(self._site_root), self._site_root
        assert osp.isdir(self._sdk_reference_dir), self._sdk_reference_dir
        assert osp.isdir(self._templates_dir), self._templates_dir

        self._copy_pages()
        self._move_api_summary()
        self._add_page_headers()
        self._fix_page_links_and_references()
        self._fix_parsing_problems()


def parse_args(args=None):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--input-dir",
        type=osp.abspath,
        default="cvat-sdk/docs/",
        help="Path to the cvat-sdk/docs/ directory",
    )
    parser.add_argument(
        "--site-root",
        type=osp.abspath,
        default="site/",
    )

    return parser.parse_args(args)


def main(args=None):
    args = parse_args(args)
    processor = Processor(input_dir=args.input_dir, site_root=args.site_root)
    processor.run()
    return 0


if __name__ == "__main__":
    sys.exit(main())
